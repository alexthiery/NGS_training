---
title: "ATACSeq_Session_2"
date: "2023-03-09"
output:
  html_document:
    df_print: paged
---

</br>

### **ATAC Session 2**
</br>

We will conduct bulk ATACseq analysis in R using [DESeq2](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8) for data normalisation and differential accessibility testing.

This tutorial is focussed on the data objects used during DESeq2 differential expression analysis.

</br>

#### **Setup working environment**

First we need to set up our working environment, including some parameters for the plots we will make later.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=8, fig.height=8) 
```

We first need to install some R packages. These packages include functions that we will use to manipulate and visualise our ATAC-seq data.  

Required packages:  
- 'dplyr' and 'data.table' - packages for handling dataframes.    
- DESeq2 - package to run differential expression (or for ATAC accessibility) tests.   

Required helper packages:  
- 'BiocManager' - a package that helps us install the above packages. 

```{r installation, results = 'hide', message=FALSE, warning=FALSE}

# Set up params for installation
r <- getOption("repos")
r["CRAN"] <- "http://cran.cnr.berkeley.edu/"
options(repos = r)
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager", repos = "http://cran.us.r-project.org")

# Install BiocManager packages
BiocManager::install(version = "3.16")
BiocManager::install("DESeq2")

## Install CRAN packages
install.packages("dplyr")
install.packages("data.table")

```

Load packages

```{r, message=FALSE, warning=FALSE}
library(data.table)
library(dplyr)
library(DESeq2)
library(ggplot2)
```

</br>

#### **Data pre-processing**

# Peak calling outputs

In the last session we worked with the aligned reads directly, however in ATAC-seq data we can often use peaks instead of all reads. Peaks are regions of the genome where lots of reads have mapped, they are identified by peak calling algorithms such as [Macs2](https://hbctraining.github.io/Intro-to-ChIPseq/lessons/05_peak_calling_macs.html). 

Peak calling can be performed on each sample individually or on all the samples and replicates together. We are going to look at a consensus peak set that was called on our 6 samples (3 conditions, 2 replicates of each). You can see how this consensus peak set appeared in the different samples in the consensus_peaks pdf file. 

There are usually 2 outputs of peak calling: 
1) a Peaks BED object (either not annotated (1.1) or annotated (1.2)) that describes the genomic coordinates of the peaks that have been called        
2) a Peak Count Matrix that shows how often reads map to this peak in each sample      

### 1.1) Peaks BED

BED files define features along a genome. They include: the name of the feature (in this case 'Interval_X'), the chromosome that the feature is on, the start and end coordinates of the feature and the strand that the feature is on (+ or -). 

```{r read_peak_bed}

# path for the peaks bed file
peaks_bed_path <- "./data/NF-ATACseq_alignment/bwa/merged_library/macs2/broad_peak/consensus/consensus/consensus_peaks.mLb.clN.bed"

# read in file
peaks_bed <- as.data.frame(read.table(peaks_bed_path, header = FALSE, sep="\t",stringsAsFactors=FALSE, quote=""))

# print file
print(head(peaks_bed))

```

##### Q: How many peaks do we have in total?

A: There are 104,659 rows in 'peaks_bed' (each row corresponds to a peak)


##### Challenge: What are the sizes of the biggest and smallest peaks in the dataframe?

The dataframe 'peaks_bed' includes the start coordinate and end coordinates, so the difference between the two will give you the size of the peaks. 
There are a few ways you can calculate peak sizes and identify the biggest one, here is one way which makes use of the package 'dplyr':

```{r identify_biggest_and_smallest_peak}

peaks_bed %>% 
  mutate(peak_size = V3 - V2 + 1) %>%
  arrange(peak_size)

```

The resulting dataframe is ordered by peak size, the smallest size is at the top (146bp) and biggest at the bottom (167bp). Note that when you print the table on rstudio it may not show you every row to save space!


### 1.1) Annotated Peaks BED

In order to give our peak coordinates biological context, we need to know where they are relative to genes and other annotated features of the genome. Annotation of the peaks BED file can be done manually by intersecting two BED files: the peaks BED file and the genome annotations BED file. This can be done using a function called [bedtools intersect](https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html). In our case, the NF-core pipeline already includes a step that annotated the peak bed file so we only have to read it in. 


```{r annotate_peak_bed}

annot_peaks_bed_path <- "./data/NF-ATACseq_alignment/bwa/merged_library/macs2/broad_peak/consensus/consensus/consensus_peaks.mLb.clN.annotatePeaks.txt"

annot_peaks_bed <- read.table(annot_peaks_bed_path, header = TRUE, sep="\t", stringsAsFactors=FALSE, quote="")

print(head(annot_peaks_bed))

```

Now that we have these peaks and their annotations we can do some investigations eg looking at what regions of the genomes most peaks come from (gene bodies, intergenic, etc. ) 

???Make some pie charts???

plotAnnoPie(peak_count_matrix) from ChIPseeker package?

### 2) Peak Count Matrix

Now that we know what the peaks are, the next important information is to know how accessible these peaks are between samples. Usually we are interested in peaks that are different between our conditions but not our replicates. This information is stored in the peak count matrix. 

```{r peak_count_matrix}

peak_count_matrix_path <- "./data/NF-ATACseq_alignment/bwa/merged_library/macs2/broad_peak/consensus/consensus/consensus_peaks.mLb.clN.featureCounts.txt"

peak_count_matrix <- read.table(peak_count_matrix_path, header = TRUE, sep="\t", stringsAsFactors=FALSE, quote="")

print(head(peak_count_matrix))

```

##### Activity: Can you reorder the peak_count_matrix to confirm that the smallest and largest peak sizes are what we expected?

```{r reorder_matrix}

peak_count_matrix %>% 
  arrange(Length)

```

By reordering the peak matrix we can see that the smallest peak is 146bp and largest is 167bp, which matches what we saw before. 

</br>

#### **Prepare peak counts for DESeq2**

This peak count matrix includes count values for our 6 samples (3 conditions, 2 replicates for each), but it also includes other columns with information about the peaks (Chr, Start, End, Strand, Length). So the first thing we want to do is clean up our dataframe to just have our peak counts with clear column names:

```{r cleanup}

# just take counts from data frame
dim(peak_count_matrix)
counts <- peak_count_matrix[,7:12]
dim(counts)

# remove endings of colnames
colnames(counts) <- gsub("\\..*", "",  colnames(counts))

# add peak names to the first column of the count df
counts <- counts %>% mutate(peak_ID = peak_count_matrix$Geneid)

# reorder columns
counts <- counts %>% select(peak_ID, GM12878_STD_REP1, GM12878_STD_REP2, GM12878_FAST_REP1,
                            GM12878_FAST_REP2, GM12878_OMNI_REP1, GM12878_OMNI_REP2)

# make peak IDs the rownames
counts2 <- counts[,-1]
rownames(counts2) <- counts[,1]
counts <- counts2

# check cleaned df
print(head(counts))

```

```{r counts_distribution}

boxplot(counts$GM12878_STD_REP1)
hist(counts$GM12878_STD_REP1, breaks = 100)
pw = log(counts$GM12878_STD_REP1 + 1)
boxplot(pw)
hist(pw, breaks = 100)

```


</br>

#### **Initialise DESeq2 object**

Now that we have our peak counts and peak annotation dataframe, we are ready to initialise our DESeq2 object.

DESeq2 requires sample metadata in order to know the groupings required for differential expression testing.
The sample metadata needs to be provided as a dataframe containing the sample names as rownames, an column titled 'Group' which specifies the condition. Additional columns specifying additional covariates can also be added if required.

```{r col_data_setup}

# set up metatdata table
col_data <- data.frame(colnames(counts)[2:7])
colnames(col_data) <- "sample_name"
col_data <- col_data %>% 
  mutate(condition = sapply(strsplit(as.character(col_data$sample_name), "_"), `[`, 2)) %>%
  mutate(replicate = sapply(strsplit(as.character(col_data$sample_name), "_"), `[`, 3))

print(col_data)

```

Now it's time to initialise the DESeq2 object.

The design argument is required to specify the sample groupings used for subsequent differential expression tests. In this example we are just wanting to look at genes differentially expressed between the different cell lines, so our experimental design is to look at gene expression as a function of 'Group'. More complex formulas can be added here to account for additional covariates. See [DESeq2 documentation](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#how-can-i-include-a-continuous-covariate-in-the-design-formula:~:text=and%20baySeq.-,Quick%20start,-Here%20we%20show) for more detail.

``` {r}
deseq <- DESeqDataSetFromMatrix(counts, design = ~ condition, colData = col_data)
```

Next I set the reference level of the Group column to STD. Usually this would be set to your control sample, purely to make subsequent fold change calculations relative to your control.
```{r}
deseq$Group <- relevel(deseq$condition, ref = "STD")
```

An important step in preprocessing is to remove peaks with very low accessibility. This helps to reduce the size of the dataset whilst also removing peaks for which we have not captured meaningful biological variation.

Here I am filtering peaks which have fewer than 5 counts in at least 2 samples
```{r}
deseq <- deseq[rowSums(counts(deseq) > 5) >= 2, ]
```

</br>

#### **Run DESeq2**

The standard differential expression analysis steps are wrapped into a single function, DESeq.

During this step, DESeq2 will:
  1) Normalise the data usingthe medians of ratios method, which effectively corrects for differences in sequencing depth and RNA composition between samples.
  2) Calculate gene dispersion estimates
  3) Fit generalised linear models of gene expression for each gene

```{r}
deseq <- DESeq(deseq)
```
Results tables of specific pairwise differential expression tests can then be retrieved using the *results* function. This extracts a results table with log2 fold changes, p-values and adjusted p-values.

``` {r}
res <- results(deseq)
res
```

``` {r}
resultsNames(deseq)
```
By default, DESeq2 will compare the last variable in the design condition to the reference level previously set using the *relevel* function.

Instead, results for specific pairwise tests of interest can be extracted using the following commands, where *condition* can be replaced with the metadata column containing your variable of interest, and *OMNI* and *FAST* can be replaced with your condition of interest and reference condition respectively.

``` {r}
res <- results(deseq, name=c("condition_OMNI_vs_FAST"))
res
```

We use the DESeq2 function lfcShrink in order to calculate more accurate log2FC estimates. This uses information across all genes to shrink LFC when a gene has low counts or high dispersion values.

``` {r}
res <- lfcShrink(deseq, coef=c("condition_OMNI_vs_FAST"))
res
```

A summary table of the results for a given adjusted p-value threshold (alpha) can also easily be printed.

``` {r}
summary(res, alpha = 0.05)
```

### now just need to add some plots eg sizeFactors, plotDispEsts
### then some sample QC plots eg sample-sample correlation and PCA









##############
# DESeq2 results

### 1) Size factors

Size factors are the values for which accessibility in each sample is scaled for in order to account for sequencing depth. Further information as to why and how these size factors are calculated can be found [here](https://hbctraining.github.io/DGE_workshop/lessons/02_DGE_count_normalization.html).


```{r sizefactors}
sizeFactors(dds)
```

### 2) Dispersion estimates

What is dispersion?
Dispersion is the within-group variability that describes how much the variance deviates from the mean. This is important because for gene or peak counts, variance does not equal the mean. Usually, genes or peaks which are lowly expressed or accessible have higher variance compared to genes or peaks which are highly expressed/accessible. Dispersion estimates reflect the variance in gene expression or peak accessibility for a given mean value. 

We use the DESeq2 function 'lfcShrink' to calculate more accurate log2FC estimates. This uses information across all genes to shrink LFC when a gene has low counts or high dispersion values.

``` {r lfcshrink}
res <- lfcShrink(deseq, coef="Group_Lmx1a_E1_vs_Sox3U3", type="apeglm")
```

We can visualise the dipersion before and after shrinking. 

```{r dispersion_plot}

plotDispEsts(dds)

```

?? Maybe mention LRT if your conditions are continuous rather than categorical 



### Examining results

Can see here when we print out he results 'res' that the test we have performed was OMNI condition vs the STD condition. 
We can also specific which pairwise test we want to extract from the dds object using the 'contrast' parameter. 

```{r DESeq2_examine}

res <- results(dds)
print(res)

res_1 <- results(dds, contrast=c("condition","FAST","STD"))
print(res_1)

res_1 <- results(dds, contrast=c("condition","FAST","OMNI"))

```
You can reorder the results based on the p values

```{r deseq2_res_reorder}
res <- res[order(res$padj),]
head(res)
```



### PCA

A principle component analysis (PCA) plot is a good way to check that your replicates are similar to each other but different from the replicates of another condition. 


```{r PCA, fig.height = 10, fig.width = 5}

# calculate PCA
vsdata <- vst(dds, blind=FALSE)

# reset par
par(mfrow=c(1,1))

# make plot
plot <- plotPCA(vsdata, intgroup="condition")
plot + coord_fixed(ratio = 1.5)

```

### Volcano Plot
```{r volcano_plot}

#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-3,3)))

# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(res, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))

```




