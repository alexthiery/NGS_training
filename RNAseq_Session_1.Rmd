---
title: "Bulk RNAseq analysis"
output:
  html_document
author: "Alex Thiery"
date: "2023-01-20"
---

### **R tutorial 1**
</br>

We will conduct bulk RNAseq analysis in R using [DESeq2](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8) for data normalisation and differential expression testing.

This tutorial is focussed on the data objects used during DESeq2 differential expression analysis.

</br>

#### **Setup working environment**


```{r setup}
knitr::opts_knit$set(root.dir = '~/Downloads/')
```

Set working directory
```{r}
setwd('~/Downloads/')
```

First we need to install the required packages

```{r, message=FALSE, warning=FALSE}
if (!require("tidyverse", quietly = TRUE))
    install.packages("tidyverse", repos = "http://cran.us.r-project.org")

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager", repos = "http://cran.us.r-project.org")

BiocManager::install(version = "3.16")
BiocManager::install("DESeq2")
BiocManager::install("apeglm")
```

Load packages

```{r, message=FALSE, warning=FALSE}
library(DESeq2)
library(apeglm)
library(tidyverse)
```

It is useful to first set the paths where you want to save your outputs. I am adding these paths at the top of this script so that each of you can easily change the paths without causing any issues downstream
```{r, message=FALSE, warning=FALSE}
output_path <- './output/'
dir.create(output_path, recursive = TRUE)
```

</br>

#### **Data pre-processing**

Read in transcript pseudo-counts from the alignment
```{r}
read_counts <- read.delim('https://raw.githubusercontent.com/alexthiery/NGS_training/main/data/NF-RNAseq_alignment/salmon.merged.gene_counts.tsv', stringsAsFactors = FALSE)
```

The first thing we need to do is check that all our gene names are unique - if not this can cause problems downstream if we want to be able to distinguish between two transcripts which have the same gene name. Therefore it is useful to first create a gene annotation dataframe with both unique gene ids and names before running any downstream analysis

</br>

#### Challenge 1: Check whether all gene names are unique, then check whether all gene ids are unique.
Tip - you can do this by checking if any elements of an array are duplicated

<button class="btn btn-primary" data-toggle="collapse" data-target="#BlockName2"> Show solution </button>  
<div id="BlockName2" class="collapse">
```{r}
any(duplicated(read_counts$gene_id))
any(duplicated(read_counts$gene_name))
```

You can see here that gene ids are all unique, this is because gene ids are associated with unique genome co-ordinates. This isn't necessarily the case with gene names!
</div>

</br>

We can make gene names unique by using adding an index and using "_" as a separator
```{r}
read_counts$gene_name <- make.unique(read_counts$gene_name, sep = "_")
```

Now that we have unique gene ids and gene names, we can create an annotations dataframe for safekeeping. This provides us a reference map to identify which gene id a specific gene of interest initially came from
```{r}
gene_annotations <- read_counts %>% dplyr::select(gene_id, gene_name)
write.csv(gene_annotations, paste0(output_path, "gene_annotations.csv"), row.names = F)
```

</br>

#### **Prepare transcript counts for DESeq2**

DESeq2 expects read counts to be integers by default. This RNAseq data was aligned using a pseudo-aligner which estimates transcript abundances without the need to explicitly assign reads to a specific transcript. This is can provide more accurate transcript abudance estimates when the sequencing read cannot distinguish between potential splice variants. More information regarding this is discussed in the introduction to RNAseq session.

We can convert the estimated transcript abundances to count data using the following command.
Here we are selecting all the numeric columns of the dataframe and converting them to integers

``` {r}
# In tidyverse
read_counts <- read_counts %>% mutate(across(where(is.numeric), as.integer))

# In base R
read_counts[,-c(1:2)] <- apply(read_counts[,-c(1:2)], 2, as.integer)
```

Before we load our data in to DESeq2, we first want to set the gene names as the rownames of the read_counts object, we then want to remove the gene_id and gene_annotation columns from our dataframe as DESeq2 expects a dataframe containing only count data.

``` {r}
rownames(read_counts) <- read_counts$gene_name
read_counts[,1:2] <- NULL
head(read_counts)
```


Finally save the new readcounts output with unique gene ids, unique gene names and sample read counts as a CSV for future use

``` {r}
write.csv(read_counts, paste0(output_path, "read_counts.csv"), row.names = TRUE)
```

</br>

#### **Initialise DESeq2 object**

Now that we have our read counts and gene annotation dataframe, we are ready to initialise our DESeq2 object.

DESeq2 requires sample metadata in order to know the groupings required for differential expression testing.

If we look at the column names of our dataset, we can see we have 4 conditions, each with two replicates:
* GM12878 immortalized cell line
* K562 immortalized cell line
* MCF7 immortalized cell line
* H1 hESC

```{r}
colnames(read_counts)
```


The sample metadata needs to be provided as a dataframe containing the sample names as rownames, an column titled 'Group' which specifies the condition. Additional columns specifying additional covariates can also be added if required.

Below I extract sample groups and replicate information from the sample names themselved.

``` {r}
col_data <- data.frame(
  row.names = colnames(read_counts),
  Group = factor(sub("_.*", "", colnames(read_counts))),
  Replicate = sub(".*REP", "", colnames(read_counts))
)
```

Now it's time to initialise the DESeq2 object.

The design argument is required to specify the sample groupings used for subsequent differential expression tests. In this example we are just wanting to look at genes differentially expressed between the different cell lines, so our experimental design is to look at gene expression as a function of 'Group'. More complex formulas can be added here to account for additional covariates. See [DESeq2 documentation](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#how-can-i-include-a-continuous-covariate-in-the-design-formula:~:text=and%20baySeq.-,Quick%20start,-Here%20we%20show) for more detail.

``` {r}
deseq <- DESeqDataSetFromMatrix(read_counts, design = ~ Group, colData = col_data)
```

An important step in RNAseq preprocessing is to remove genes with very low expression. This helps to reduce the size of the dataset whilst also removing genes for which we have not captured meaningful biological variation.

</br>

#### Challenge 2: Filter the genes which have fewer than 5 counts in at least 2 samples. 

<button class="btn btn-primary" data-toggle="collapse" data-target="#BlockName2"> Show solution </button>  
<div id="BlockName2" class="collapse">
```{r}
deseq <- deseq[rowSums(counts(deseq) > 5) >= 2, ]
```

</div>

</br>

Next I set the reference level of the Group column to GM12878. This reference level is your control sample. Subsequent pairwise differential expression test compare different conditions relative to this control.
```{r}
deseq$Group <- relevel(deseq$Group, ref = "GM12878")
```

</br>

#### **Run DESeq2**

The standard differential expression analysis steps are wrapped into a single function, DESeq.

During this step, DESeq2 will:
  1) Normalise the data using the medians of ratios method, which effectively corrects for differences in sequencing depth and RNA composition between samples.
  2) Calculate gene dispersion estimates
  3) Fit generalised linear models of gene expression for each gene

```{r}
deseq <- DESeq(deseq)
```


Next, we want to visualise the overall relationship between different samples and replicates. For this, we need to first use DESeq2's *rlog* or *vst* functions to transform the data to prevent the highest expressed genes from dominating. This is used for applications other than differential testing, for example when clustering the samples.

```{r}
rld <- rlog(deseq)
```

Next, we can run PCA analysis for dimensionality reduction in order to visualise the relationship between samples in 2-dimensions.

You can see here from the output that for each condition, there are two replicates which cluster very closely together. This shows that their is low  variability between biological replicates, and therefore that most of the variation observed is due to the sample condition.

```{r}
plotPCA(rld, intgroup = "Group")
```

#### DESeq2 under the hood

The size factors shown below are the values for which gene expression in each sample is scaled for in order to account for sequencing depth and RNA composition.

```{r}
sizeFactors(deseq)
```

After read counts have been normalised, DESeq2 calculates gene dispersion estimates. Gene dispersion represents gene variance adjusted for gene expression level.

A more detailed explanation of how gene dispersion is calculated can be found in the '[Introduction to DESeq2](https://moodle.learninghub.kingshealthpartners.org/course/view.php?id=353&section=5)' section of this course.


``` {r}
plotDispEsts(deseq)
```

#### Differential expression

Results tables of specific pairwise differential expression tests can then be retrieved using the *results* function. This extracts a results table with log2 fold changes, p-values and adjusted p-values.

``` {r}
res <- results(deseq)
res
```


``` {r}
resultsNames(deseq)
```

By default, DESeq2 will compare the last variable in the design condition to the reference level previously set using the *relevel* function.

Instead, results for specific pairwise tests of interest can be extracted using the following commands, where *Group* can be replaced with the metadata column containing your variable of interest, and *H1* and *K562* can be replaced with your condition of interest and reference condition respectively.

``` {r}
res <- results(deseq, name=c("Group_K562_vs_GM12878"))
res
```

If you would like to carry out pairwise tests between conditions other than your control, you can change the reference sample using *relevel*. Here, let's set the reference level to the hESC line.

```{r}
deseq$Group <- relevel(deseq$Group, ref = "H1")
deseq <- DESeq(deseq)
resultsNames(deseq)
res <- results(deseq, name=c("Group_MCF7_vs_H1"))
res
```

We use the DESeq2 function lfcShrink in order to calculate more accurate log2FC estimates. This uses information across all genes to shrink LFC when a gene has low counts or high dispersion values.

``` {r}
res <- lfcShrink(deseq, coef=c("Group_MCF7_vs_H1"), type = 'apeglm')
res
```

</br>

#### Challenge 3: Identify which gene has the highest log2FC when comparing MCF7 vs K562. 

<button class="btn btn-primary" data-toggle="collapse" data-target="#BlockName2"> Show solution </button>  
<div id="BlockName2" class="collapse">
First you need to relevel the deseq object so you perform the correct test (MCF7 vs K562), then you need to reorder the results to extract the highest LogFC gene. 
```{r}
deseq$Group <- relevel(deseq$Group, ref = "K562")
deseq <- DESeq(deseq)
resultsNames(deseq)
res <- results(deseq, name=c("Group_MCF7_vs_K562"))
head(res[order(res$log2FoldChange, decreasing = TRUE),])
```

</div>

</br>

A summary table of the results for a given adjusted p-value threshold (alpha) can also easily be printed.

``` {r}
summary(res, alpha = 0.05)
```


We can save the output deseq object for our next session on visualisation with heatmaps and volcano plots
``` {r}
saveRDS(deseq, paste0(output_path, 'deseq_output.RDS'))
```

